---
layout: post 
title: Claude Code Framework Wars
blog_url: https://shmck.substack.com/p/claude-code-framework-wars?utm_source=tldrai 
---

## Overview

The article highlights the ongoing experimentation within the developer community to build frameworks around AI coding tools like Claude. It emphasizes that treating AI as a structured framework, rather than a simple chatbox, significantly enhances its productivity by defining rules, roles, and workflows. The piece outlines seven key decisions in designing a Claude setup, including task management, guidance mechanisms, agent coordination, session execution, tool access, code development roles, code delivery, and context preservation, ultimately presenting AI as a managed teammate in the software development lifecycle.

## Key Points

- Developers are actively experimenting with frameworks to optimize AI coding tools like Claude.
- Treating AI as a structured framework with defined rules and roles is crucial for predictable and valuable output.
- Key design choices for a Claude setup include where tasks reside (e.g., Markdown backlogs, GitHub Issues).
- Guiding Claude effectively involves clear commands, coding standards, and definition of 'done' criteria.
- Agent coordination is achieved through role simulation (PM, architect, developer) and swarm parallelism.
- Session management focuses on terminal orchestration, parallel worktrees, and isolated containers.
- Tool access is critical, utilizing MCP integrations, custom tool libraries, and testing/validation hooks.
- Code development leverages AI in various roles: PM, Architect, Implementer, QA, and Code Reviewer.
- Code delivery emphasizes small diffs, experiments with feature flags, or full app scaffolds.
- Context preservation is vital, achieved through documentation (CLAUDE.md) and persistent memory mechanisms.

## Key Topics Discussed

The article, "Claude Code Framework Wars," explores the dynamic landscape of developers creating frameworks to optimize their interaction with AI coding assistants like Claude. It asserts that to unlock the full potential of AI in software development, it must be treated not merely as a chat interface but as a structured framework complete with defined rules, roles, and workflows that ensure predictable and valuable outputs. The author identifies seven critical decisions involved in designing an effective Claude setup. These include determining where tasks reside, such as in Markdown backlogs or GitHub Issues, and how Claude is guided through clear command libraries and coding standards to enforce a "definition of done." The coordination of multiple AI agents is addressed through role simulation (e.g., AI as a Project Manager, Architect, Developer, or Tester) and swarm parallelism for structured task execution. Session management focuses on practical workstation setups like terminal orchestration and parallel worktrees or containers for isolated development. Crucially, the article highlights the importance of providing Claude with robust tool access via Model Context Protocol (MCP) integrations, custom libraries, and testing hooks to enable self-validation. It further elaborates on how AI can be leveraged in various stages of code development, from project management and architectural design to implementation, quality assurance, and code reviews. For code delivery, the emphasis is on flexible approaches, from small, reviewable pull requests to deploying full application scaffolds. Finally, the article underscores the necessity of context preservation through detailed documentation and persistent memory systems to prevent AI from repeating mistakes and to foster continuous progress. The core takeaway is that while AI isn't replacing developers, it's shifting their roles towards higher-value activities like shaping specifications and designing architecture, with the rule being: "the more structure you give, the more you get back."

