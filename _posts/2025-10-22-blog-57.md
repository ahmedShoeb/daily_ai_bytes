---
layout: post 
title: "Everything you need to know to secure your MCP server using OAuth 2.1 and PKCE, server and auth metadata, client registration, JWT validation, and role-based access control."
blog_url: https://workos.com/blog/mcp-auth-developer-guide?utm_source=tldrai&utm_medium=newsletter&utm_campaign=q32025 
---



## Key Points

MCP servers require strong security due to AI agents' increasing capabilities and access to systems.
The guide focuses on securing MCP using OAuth 2.1 and PKCE, alongside server and auth metadata, client registration, JWT validation, and RBAC.
MCP architecture involves a host, client, and server, with all client-server requests requiring authentication and authorization.
OAuth 2.1 is the recommended production standard for MCP authentication, using scoped, time-limited tokens instead of API keys.
PKCE (Proof Key for Code Exchange) is essential for securing public MCP clients that cannot store secrets.
MCP servers leverage Protected Resource Metadata (RFC 9728) and Authorization Server Metadata (RFC 8414) for discovery and configuration.
Dynamic Client Registration (RFC 7591) allows clients to automatically register with authorization servers.
Access tokens, typically JWTs, must undergo strict validation by the MCP server, verifying signature, expiry, issuer, audience, and scope.
Role-Based Access Control (RBAC) enforces access by mapping roles to OAuth scopes, ensuring clients only perform authorized actions.
WorkOS provides solutions for implementing OAuth as an MCP server, supporting existing user bases or managing logins via AuthKit.

## Key Topics Discussed

Hey there, tech enthusiasts! Today, we're diving into the critical world of securing your MCP servers, especially as AI agents become more powerful and interconnected. This comprehensive guide from WorkOS breaks down exactly how to protect your systems using robust authentication and authorization mechanisms. At its core, MCP's architecture involves three main players: the host, which is your AI-powered application; the client, managing the MCP protocol; and the server, where all the heavy-lifting and actions happen. Every single request between the client and server demands both authentication—knowing who is making the request—and authorization—what they're actually allowed to do. While simple API keys might work for quick prototypes, the article strongly advocates for OAuth 2.1 as the gold standard for production environments. OAuth replaces those risky, static API keys with dynamic, time-limited tokens that are precisely scoped to specific permissions. This means if a token is compromised, its impact is limited, and it can be revoked easily. A crucial aspect for public MCP clients, which can't safely store secrets, is the implementation of PKCE, or Proof Key for Code Exchange. This clever mechanism ensures secure authentication without ever exposing sensitive client secrets. The article also highlights the importance of metadata standards. MCP servers publish Protected Resource Metadata (RFC 9728) to inform clients about their security configurations, such as acceptable token formats and trusted authorization servers. Similarly, Authorization Server Metadata (RFC 8414) helps clients understand how to communicate with OAuth servers, listing endpoints and supported features. To streamline the onboarding of new clients, Dynamic Client Registration (RFC 7591) allows clients to automatically register with authorization servers, making the MCP ecosystem scalable and self-serve. Once an MCP client gets an access token, typically a JWT, the MCP server has to rigorously validate it. This involves checking the token's signature to ensure it's from a trusted issuer, verifying its expiry, confirming the issuer and audience, and crucially, checking if the token includes the necessary scopes for the requested action. This validation process is absolutely vital for preventing unauthorized access to sensitive data. Finally, to enforce what an authenticated user or service can actually do, Role-Based Access Control (RBAC) comes into play. RBAC maps roles to sets of permissions, which correspond to those OAuth scopes. This ensures that even with a valid token, clients can only perform actions that align with their assigned roles and permissions. WorkOS offers practical solutions to implement all these security measures, whether you're bringing your own user directory or utilizing their AuthKit for managing logins. By following these guidelines, you can build an MCP server that is secure by design, auditable, and scalable for the ever-evolving world of AI.

